<resources>
    <string name="app_name">My Application</string>
    <string name="title_activity_home">Home</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Android Studio</string>
    <string name="nav_header_subtitle">android.studio@android.com</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="menu_home">Home</string>
    <string name="menu_gallery">Gallery</string>
    <string name="menu_slideshow">Slideshow</string>
    <string name="menu_tools">Tools</string>
    <string name="menu_share">Share</string>
    <string name="menu_send">Send</string>
    <string name="title_activity_lecture">Lecture</string>
    <string name="title_activity_assessment_task">AssessmentTask</string>


    <string name="midtermtwo"><![CDATA[<p>Exception handling is the process of responding to exceptions when a computer
    program runs. An exception occurs when an unexpected event happens that requires special
    processing.</p><br>

    <p>Exception handling attempts to gracefully handle these situations so that a program does
    not crash. Exception handling can be performed at both the software and hardware levels.</p><br>

    <b>Hierarchy of Java Exception classes</b><br><br>


    <p>The java.lang.Throwable class is the root class of Java Exception hierarchy which is inherited by
    two subclasses: Exception and Error</p>
    ]]></string>

    <string name="midtermtwo_midtermtryandcatch"><![CDATA[<p>•The <b>try</b> statement allows you to define a block of code to be tested for errors while it is
    being executed.</p><br>

    <p>•The <b>catch</b> statement allows you to define a block of code to be executed, if an error
    occurs in the try block..</p><br>

    <p>•The <b>throw</b> statement allows you to create a custom error.</p><br>

    <b>Types of Java Exceptions</b> <br>

    <p>There are mainly two types of exceptions: checked and unchecked. Here, an error is considered
    as the unchecked exception. According to Oracle, there are three types of exceptions: </p> <br>

    <p>1. Checked Exception <br>

    •The classes which directly inherit Throwable class except RuntimeException and
    Error are known as checked exceptions. Checked exceptions are checked at compile-
    time. <br>

    2. Unchecked Exception <br>

    •The classes which inherit RuntimeException are known as unchecked exceptions.
    Unchecked exceptions are not checked at compile-time, but they are checked at
    runtime. <br>

    2. Error <br>

    •Error is irrecoverable <br>

    </p>

    ]]></string>

    <string name="midtermtwo_userdefinedexception"><![CDATA[<p>•User Defined Exception or custom exception is creating your own exception class and
    throws that exception using ‘throw’ keyword. This can be done by extending the class
    Exception.</p><br>

    <p>•There is no need to override any of the above methods available in the Exception class,
    in your derived class.  But practically, you will require some amount of customizing as
    per your programming needs.</p><br>

    ]]></string>

    <string name="midtermtwo_assertions"><![CDATA[<p>•An assertion is a statement in Java which ensures the correctness of any assumptions
    which have been done in the program. When an assertion is executed, it is assumed to
    be true. If the assertion is false, the JVM will throw an Assertion error. It finds it
    application primarily in the testing purposes. Assertion statements are used along with
    boolean expressions.</p><br>

    <p>•Assertions in Java can be done with the help of the assert keyword. There are two ways
    in which an assert statement can be used.</p><br>

    <b>Advantage of Assertion</b> <br>
    <p>- It provides an effective way to detect and correct programming errors.</p> <br>

    <b>Syntax of using Assertion:</b> <br>
    <p>There are two ways to use assertion. <br>
    1. assert expression; <br>
    2. assert expression1 : expression2;
    </p>

    ]]></string>

    <string name="midtermone"><![CDATA[<p>When an escape sequence is encountered in a print statement, the compiler interprets it accordingly. For
    example, if you want to put quotes within quotes you must use the escape sequence, \&quot;, on the interior
    quotes. To print the sentence.</p><br>

    &emsp She said &quot;Hello!&quot; to me.<br>
    you would write <br>
    &emsp System.out.println(&quot;She said \&quot;Hello!\&quot; to me.&quot;);<br><br>


    <p>
    Java provides three classes to represent a sequence of characters: <b>String, StringBuffer </b>, and
    <b>StringBuilder</b>. The String class is an immutable class whereas StringBuffer and StringBuilder classes are
    mutable. There are many differences between StringBuffer and StringBuilder. The StringBuilder class is
    introduced since JDK (Java Development Kit) 1.5. <br> <br>

    <b>String</b> is basically an object that represents sequence of char values. String works the same as n array of
    characters. For example: <br> <br>

    &emsp char[] ch = {&#39;j&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;p&#39;,&#39;o&#39;,&#39;i&#39;,&#39;n&#39;,&#39;t&#39;}; <br>
    &emsp String s = new String(ch); <br>

    Is the same as:<br>

    &emsp String s = &quot;javatpoint&quot;; <br> <br>

    <b>String</b> class provides a lot of methods to perform operations on string such as compare(), concat(),
    equals(), split(), length(), replace(), compareTo(), intern(), substring() etc. <br>
    The java.lang.String class implements Serializable, Comparable and CharSequence interfaces. <br>
    </p>

    ]]></string>

    <string name="midtermthree"><![CDATA[Two different ways to create an array. <br>
    1. <b>Array</b>: Simple fixed sized arrays that we create in Java <br>
    &emsp int arr [] = new int [10] <br> <br>

    2. <b>ArrayList</b> : Dynamic sized arrays in Java that implement List interface. <br>
    &emsp ArrayList&lt;Type&gt; arrL = new ArrayList &lt;Type&gt; (); <br>
    &emsp Here Type is the type of elements in ArrayList to be created <br> <br>


    <b>Differences between Array and ArrayList</b> <br>
    <p>•An array is a basic functionality provided by Java. ArrayList is part of collection
    framework in Java. Array members are accessed using [], while ArrayList has a set of
    methods to access elements and modify them.</p><br> <br>

    <p>•Array is a fixed size data structure while ArrayList is not. One need not to mention the size
    of Arraylist while creating its object. Even if we specify some initial capacity, we can add
    more elements.</p><br> <br>

    <p>•Array can contain both primitive data types as well as objects of a class depending on the
    definition of the array. However, ArrayList only supports object entries, not the primitive
    data types.</p><br> <br>

    <p>•ArrayList can’t be created for primitive data types, members of ArrayList are always
    references to objects at different memory locations. In ArrayList, the actual objects are
    never stored at contiguous locations. References of the actual objects are stored at
    contiguous locations. In array, it depends whether the arrays is of primitive type or object
    type. In case of primitive types, actual values are contiguous locations, but in case of
    objects, allocation is similar to ArrayList.</p><br> <br>

    ]]></string>

    <string name="midtermthree2DandMDArray"><![CDATA[<p>Java ArrayList class uses a dynamic array for storing the elements. It inherits AbstractList class
    and implements List interface. </p> <br>

    The important points about Java ArrayList class are: <br>
    • Java ArrayList class can contain duplicate elements. <br>
    • Java ArrayList class maintains insertion order. <br.
    • Java ArrayList class is non synchronized. <br>
    • Java ArrayList allows random access because array works at the index basis. <br>
    • In Java ArrayList class, manipulation is slow because a lot of shifting needs to occur
    if any element is removed from the array list. <br>

    ]]></string>

    <string name="MidtermFourInterface"><![CDATA[
    <b>Interface</b> <br>
    • An interface is a reference type, similar to a class, that can contain only constants,
    method signatures, default methods, static methods, and nested types. Method bodies
    exist only for default methods and static methods. <br>
    • It should be noted that interfaces cannot be instantiated as they can only
    be implemented by classes or extended by other interfaces. This is the basic difference
    between interfaces and classes. Also note that the method signatures in an interface
    have no braces and are terminated with a semicolon, which is not the case in a class
    method definition. <br.
    • Interfaces are used for abstraction. Since methods in interfaces does not have body,
    they have to be implemented by the class before you can access them. The class that
    implements interface must implement all the methods of that interface. <br>

    ]]></string>

    <string name="MidtermFourInheritancee"><![CDATA[
    <b>Inheritance</b> <br>
    • Inheritance is the process wherein characteristics are inherited from ancestors.
    Inheritance in java can be defined as a mechanism where a new class is derived from an
    existing class. It is possible for classes to inherit or acquire the properties and methods
    of other classes, just like a son can acquire some traits and behaviour from his father. <br>
    • The inheritance mechanism is very useful in code reuse. Classes can be derived from
    classes that are derived from classes that are derived from classes, and so on. In java, by
    default, the Object class is the parent class. <br.
    • Inheritance is declared using the extends keyword. You declare that one
    class extends another class by using the extends keyword in the class definition. <br>
    • For example, mammals is a super-class while human beings and animals are
    subclasses. Animals inherit all of the mammals’ properties. Subsequently, dogs can
    inherit all animals’ properties making it a subclass of the animals. <br>

    ]]></string>

    <string name="MidtermFourMethodOverriding"><![CDATA[
    • Declaring a method in sub class which is already present in parent class is known as
    method overriding. Overriding is done so that a child class can give its own
    implementation to a method which is already provided by the parent class. In this case
    the method in parent class is called overridden method and the method in child class is
    called overriding method. <br>
    • In Java, a child class has the same method as of base class. In such cases child class
    overrides the parent class method without even touching the source code of the base
    class. <br>

    ]]></string>

    <string name="MidtermFourSuperclassMethod"><![CDATA[
    • In Java, it is possible to inherit attributes and methods from one class to another. We
    group the &quot;inheritance concept&quot; into two categories: <br>
    &emsp • subclass (child) - the class that inherits from another class
    &emsp • superclass (parent) - the class being inherited from
    &emsp&emsp • To inherit from a class, use the extends keyword.

    ]]></string>

    <string name="FinalOneInputOutputStream"><![CDATA[
    • Streams are used to handle input/output operations. <br>
    • Stream is like a pipe which carries data from one end to the other. The end points are
    nothing but the source and destination of the data to be read/written. <br> <br>

    Streams are classified into two types, which are the parent class of all the subclasses of other
    streams. <br> <br>

    • <b>InputStream</b> – Superclass of all classes used to read the input. <br>
    • <b>OutputStream</b> – Superclass of all classes used to write the output. <br>

    <b>There are 3 fields in System class which represents some stream.</b>
    1. in – Represents the standard input device <br>
    2. out – Represents the standard output device <br>
    3. err – same as System.out (Errors are displayed using this field.) <br>
    <br>

    •  System.in field represents the InputStream object. Both System.out and System.err fields
    represents the PrintStream object.
    •  To accept the data from the input device, we need to connect the System.in (representing the
    basic input device) to an input stream. <br>
    <br>
    Example:  <br>


    ]]></string>


    <string name="FinalOneBytestreams"><![CDATA[
    • <b>Byte Streams</b> – ASCII 8 bits (each character requires 1 byte) <br>
    • <b>Character Streams</b> – Unicode 16 bits (each character requires 2 byte) <br>
    <br>
        <<b>BYTESTREAMS:</b>
    • Byte streams are used to read/write input/output of 8 bit bytes.All kind of data
    (text,image,audio,video) can be read/written using byte streams. <br>
    <br>
    The following diagrams shows some of the subclasses of InputStream and Output Streams which
    falls under the category of byte streams.
    Example:  <br>
    ]]></string>

    <string name="FinalOneSubclass"><![CDATA[
    • <b> 9 Subclasses of InputStream defined under the JAVA SE8</b> <br>
            ‣ AudioInputStream <br>
            ‣ ByteArrayInputStream <br>
            ‣ FileInputStream <br>
            ‣ FilterInputStream <br>
            ‣ InputStream <br>
            ‣ ObjectInputStream <br>
            ‣ PipedInputStream <br>
            ‣ SequenceInputStream<br>
            ‣ StringBufferInputStream <br>
        <br>
    ]]></string>

    <string name="FinalTwo"><![CDATA[
    • <b> Swing </b> is a GUI widget toolkit for Java. It is part of Oracle&#39;s Java Foundation
    Classes (JFC) – an API for providing a graphical user interface (GUI) for Java programs. <br>

    • Swing was developed to provide a more sophisticated set of GUI components than the
    earlier Abstract Window Toolkit (AWT). Swing provides a look and feel that emulates
    the look and feel of several platforms, and also supports a pluggable look and feel that
    allows applications to have a look and feel unrelated to the underlying platform. It has
    more powerful and flexible components than AWT. <br>

    <br>
    <br>

    <b> Difference between AWT and Swing </b>
]]></string>

    <string name="FinalTwoLayoutManager1"><![CDATA[
   <p> Every content pane is initialized to use a BorderLayout. (As Using Top-Level  Containers explains, the content pane is the main container in all frames, applets, and dialogs.) A BorderLayout places components in up to five areas: top, bottom, left, right, and center. All extra space is placed in the center area. Tool bars that are created using  JToolBar  must be created within a BorderLayout container, if you want to be able to drag and drop the bars away from their starting positions. <br>
 </p>
    <br>

    <b> • Box Layout </b>
]]></string>

    <string name="FinalTwoLayoutManager2"><![CDATA[
   <p> The BoxLayout class puts components in a single row or column. It respects the components&#39; requested maximum sizes and also lets you align components. For further details, see How to Use BoxLayout. <br>
 </p>
    <br>

    <b> • Card Layout </b>
]]></string>

    <string name="FinalTwoLayoutManager3"><![CDATA[
   <p> The CardLayout class lets you implement an area that contains different components at different times. A CardLayout is often controlled by a combo box, with the state of the combo box determining which panel (group of components) the CardLayout displays. An alternative to using CardLayout is using a tabbed pane, which provides similar functionality but with a pre- defined GUI. <br>
 </p>
    <br>

    <b> • FlowLayout </b>
]]></string>


    <string name="FinalTwoLayoutManager4"><![CDATA[
   <p>  FlowLayout is the default layout manager for every JPanel. It simply lays out components in a single row, starting a new row if its container is not sufficiently wide. Both panels in  CardLayoutDemo, shown previously, use FlowLayout. <br>
 </p>
    <br>

    <b> • GridBagLayout </b>
]]></string>

    <string name="FinalTwoLayoutManager5"><![CDATA[
   <p>  GridBagLayout is a sophisticated, flexible layout manager. It aligns components by placing them within a grid of cells, allowing components to span more than one cell. The rows in the grid can have different heights, and grid columns can have different widths. <br>
 </p>
    <br>

    <b> • GridLayout </b>
]]></string>

    <string name="FinalTwoLayoutManager6"><![CDATA[
   <p> GridLayout simply makes a bunch of components equal in size and displays them in the requested number of rows and columns. <br>
 </p>
    <br>

    <b> • GroupLayout </b>
]]></string>

    <string name="FinalTwoLayoutManager7"><![CDATA[
   <p> •  GroupLayout is a layout manager that was developed for use by GUI builder tools, but it can also be used manually. GroupLayout works with the horizontal and vertical layouts separately. The layout is defined for each dimension independently. Consequently, however, each component needs to be defined twice in the layout. The Find window shown above is an example of a GroupLayout. <br>
 </p>
    <br>

    <b> • SpringLayout </b>
]]></string>

    <string name="FinalTwoLayoutManager8"><![CDATA[
   <p> SpringLayout is a flexible layout manager designed for use by GUI builders. It lets you specify precise relationships between the edges of components under its control. For example, you might define that the left edge of one component is a certain distance (which can be dynamically calculated) from the right edge of a second component. SpringLayout lays out the children of its associated container according to a set of constraints <br>
 </p>
    <br>
]]></string>


    <string name="FinalTwoLayoutManager9"><![CDATA[
   <b> EVENT HANDLING </b> <br>
•<b> Event Handling </b> is the mechanism that controls the event and decides what should
happen if an event occurs. This mechanism has a code which is known as an event
handler, that is executed when an event occurs. Java uses the Delegation EventModel
to handle the events.   <br>
<br>

    <b> Types of Event </b> <br>

•<b> Foreground Events </b> iThese events require direct interaction of the user. They are
generated as consequences of a person interacting with the graphical components in the
Graphical User Interface. For example, clicking on a button, moving the mouse, entering
a character through keyboard, selecting an item from list, scrolling the page, etc. <br>
<br>

•<b> Background Events </b> iThese events require direct interaction of the user. They are
generated as consequences of a person interacting with the graphical components in the
Graphical User Interface. For example, clicking on a button, moving the mouse, entering
a character through keyboard, selecting an item from list, scrolling the page, etc. <br>
<br>

• Java uses the Delegation Event Model to handle the events. This model defines the
standard mechanism to generate and handle the events. <br>
 <br>
The Delegation Event Model has the following key participants.<br>

<br>
o <b>Source</b> − The source is an object on which the event occurs. Source is responsible
for providing information of the occurred event to it&#39;s handler. Java provide us with
classes for the source object. <br>

o <b>Listener</b> − It is also known as event handler. The listener is responsible for
generating a response to an event. From the point of view of Java implementation,
the listener is also an object. The listener waits till it receives an event. Once the
event is received, the listener processes the event and then returns. <br>
<br>
<br>

<b> Steps Involved in Event Handling</b> <br>
    <b>Step 1</b> − The user clicks the button and the event is generated. <br>
    <b>Step 2</b> − The object of concerned event class is created automatically and information
    about the source and the event get populated within the same object.<br>
    <b>Step 3</b> − Event object is forwarded to the method of the registered listener class. <br>
    <b>Step 4</b>− The method is gets executed and returns.<br>




]]></string>


    <string-array name="MidtermTwoLessons">
        <item>Exception Handling</item>
        <item>Try and Catch</item>
        <item>User Defined Exceptions</item>
        <item>Assertions</item>
    </string-array>

    <string-array name="MidtermThreeLessons">
        <item>Arrays and Array List</item>
        <item>Declaring and Initializing Arrays</item>
        <item>Array of Objects</item>
        <item>2D and Multidimentional Array</item>
    </string-array>

    <string-array name="MidtermFourLessons">
        <item>Inheritance and Interface</item>
        <item>Method Overriding</item>
        <item>Constructors During Inheritance</item>
        <item>Superclass Method</item>
        <item>Information Hiding</item>
    </string-array>

    <string-array name="FinalOneLessons">
        <item>Basic Input / Output</item>
        <item>File Input/Output</item>
        <item>File Input/Output Stream</item>
    </string-array>

    <string-array name="FinalTwoLessons">
        <item>Swing</item>
        <item>Swing Components </item>
        <item>Layout Manager</item>
    </string-array>

    <string-array name="FinalThreeLessons">
        <item>Applets</item>
        <item>Applet Class and Life Cycle</item>
        <item>Applet Parameters </item>
        <item>Event Handling </item>
        <item>Images and Sounds </item>

    </string-array>

</resources>
